


## Notes from [Get that Job at Google](http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html)

* [Skiena's Algorithm Design Manual](http://mimoza.marmara.edu.tr/~msakalli/cse706_12/SkienaTheAlgorithmDesignManual.pdf)
* [Intro to Algorithms](https://web.njit.edu/~wl256/download/cs610/Introduction-to-algorithm-3rdEdition.pdf)
  - Recommended as a 2nd read; extremely thorough; will take >>> 2 weeks

* Feel free to ask for help or hints if you're stuck. 
* Ask if they care about syntax
* Before any code, think outloud and ask a few questions about the approach: this is encouraged and often even expected; not doing so gives the impression that you do not carefully think things throug
* Delay-of-Game Penalty:  Don't ask too many questions or think outloud for too long before coding
* Bring in your own thin-tip dry-erase markers (lest you get stuck with the fat-tipped kind and fill the board in 2 lines of code)
* Start whiteboarding at upper left!

* Big-O notation is a necessity
* Sorting:  Bubble sort is shit.  Know how to do quicksort and merge sort (n*log(n))
  > For God's sake, don't try sorting a linked list during the interview.
* Hashtables: absolutely essential to know how they work; know how to implement one using only arrays in Python.
* Trees:  construction, traversal (BFS, DFS, inorder, postorder, preorder), and manipulation algorithms; binary trees, n-ary trees, trie-trees
* Balanced Binary Tree:  know at least one implementation (red/black, splay, or AVL)
* Graphs:  super important; know the three basic ways of representing a graph in memory (objects and pointers, matrix, adjacency list) and corresponding pros and cons
  - traversal algs: breadth-first search, depth-first search; what are their computational complexity? tradeoffs? how to implement in code?
  - better algs: Dijkstra and A* (used everywhere)
  - > Whenever someone gives you a problem, think graphs. They are the most fundamental and flexible way of representing any kind of a relationship, so it's about a 50-50 shot that any interesting design problem has a graph involved in it. Make absolutely sure you can't think of a way to solve it using graphs before moving on to other solution types. This tip is important!
* NP-Complete
  - know what it is
  - traveling salesman problem
  - knapsack problem
  - be able to recognize these problems in disguise
* Discrete Math
  - combinatorics (e.g., n choose k)
  - probability
* Operating Systems (lower priority)
  - processes,  threads,  concurrency
  - locks,  mutexes,  semaphores,  monitors
  - deadlock,  livelock
  - what resources does a process need? what resources does a thread need?
  - how does context switching work?


The [Anti-Loop](http://steve-yegge.blogspot.com/2008/03/get-that-job-at-google.html)
>> Because of the inherently flawed nature of the interviewing process, it's highly likely that someone 
>> on the loop will be unimpressed with you, even if you are Alan Turing. Especially if you're Alan Turing, 
>> in fact, since it means you obviously don't know C++.
Solution: You got the unlucky hand -- oh well.  Wait 6-12 months and try again.  (Apparently a 2nd
or 3rd attempt is not uncommon.)


## Long-Term Warm Up
* study and practice hardcore 1-2 weeks before interview
* do a lot of pen/paper and whiteboarding (this is what you'll use in the interview)


## Short-Term Warm Up
* Rest: early bed time and early rise
* Do some timed warm-ups: 5-min whiteboards
* Look over your distilled list of notes



## Graph Problems
Important.



